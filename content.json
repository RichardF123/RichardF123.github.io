{"posts":[{"title":"c++_lecture1","text":"摘要 关键词：c++ 变量类型 简单运算 输入输出方式 介绍 c++是一种可以直接编译成机器语言的高级语言，看起来比python复杂，但是更加的严谨，准确。 [1]//一个c++示例 [2]#include&lt; iostream &gt; [3]using namespace std [4]int main() [5]{ [6] cout &lt;&lt; “HELLO! CPP” &lt;&lt; endl; [7]return 0; [8]} Tips： 上面是一个简单ccode的示例，在c中标注内容前面需要使用 // 符号（这点与python不同，python中需使用#符号） c需要自己写main函数框架,2，3行代码是告诉编译器需要使用什么样的语言标准去编译代码，从第4行开始是代码内容的主体，在每行代码的末尾需要加上；符号作为结束，这里main函数的括号里是空的，c里需要返回一个值作为函数的输出，默认返回0 变量类型 从python当中我们知道变量的类型是相当重要的，运算的结果有时会因为变量的类型而发生改变 bool 布尔值 True or False char 字符串 表示字符，与python中的string一致 double 浮点数 表示小数型数字，精度更高，精确位数更多，但储存空间较大 float 浮点数 表示小数型数字，小数位越多精度越低，但所需储存空间小 int 整数 运算 运算符号与python相比并没有什么不同，唯一需要注意的是计算结果会因为参与运算的数据类型而发生改变，这是因为c++中每一次的运算都需要对参数的变量类型进行规定，而python不用 for instance： [1]int a = 123; [2]int b = 134; [3]int c = a/b; /double c = a/b; [4]cout &lt;&lt; c &lt;&lt; endl; 在这段代码当中，区别是第三行c的类型发生了改变，但是结果都是0，这是因为c++是对c进行赋值，而a/b本身就是一个整数类型的数，会向下取到下一位整数（1.22取1，1.66也取1，不是四舍五入），想要获得确切的数字就需要直接对a/b进行限定 double c = (double) a/b 或者是对a或者b进行限定，如果a或b当中有一个复数，那么a/b就是复数 输入输出 c++的输入使用cin指令，输出使用cout指令，这里与python会稍显复杂，举个例子，比如我们想要显示 Enter your name： 我们想要后面直接输入名字 在python中输入指令 str=input(‘Enter your name:’) 在c++中输入指令 char a; cout &lt;&lt; “Enter your name：”&lt;&lt; endl; cin &lt;&lt; a; 常数 我们可以定义一个常数方便运算，如果这个常数需要修改直接改就好了不需要计算的每一步都去修改，比如计算圆周面积的pi,想要精确pi值直接改 double pi 就好了","link":"/2024/01/17/CPP_lecture1/"},{"title":"c++_lecture1","text":"Pandas pandas是python中一种常用的数据分析库，对小型数据分析非常快捷方便 引入pandas库 使用import pandas as pd 简单的数组命令 创建数组 df=pd.Series([1,2,3,4,5,6]) 命名index df=pd.Series([1，2，3，4，5]，index=[‘A’,‘B’,‘C’,‘D’,‘E’]) 注意index中的元素数量应该和数组里的一样 数组的简单指令 mode ( )求众数 mean ( )求算术平均数 median ( )求中位数 min ( )求最小数 max ( )求最大数 std (ddof=0)求标准差 std (ddof=1)求样本标准差 ddof指的是自由度 sum ( )求和 var (ddof=0)求方差 var (ddof=1)求样本方差 mad ()求平均绝对离差 (描述数据离散程度) count ()计算数据量 如果数组与数组间对应的数据类型相同，且大小相同，这两个数组可以直接相加 直接描述数组 df.describe() 数组内各数的频率 df.value_counts() 联立几个数组为表格 df_new=pd.concat([S1,S2,S3…],axis=1) S1，S2…name参数不能为空 选取数据 df[‘目标数据列’] df.loc[num，‘’]前者是行数，后者是目标数据列的name df=df[df[‘’]条件] 选取数据列中符合要求的数据 创建新的数据列 如果新的数据列与原有数据列有代数关系 df[new]=df[old]operation 如果没有代数关系，就重新创一个Series再使用concat指令 csv文件相关命令 导入csv文件 df=pd.read_csv(“文件名”，header=，name=[ ]，idx_col(“”)) 保存csv df.to_csv(‘文件名’) 读取txt文本 df=pd.read_table(“文件名”，sep=) 注意，读取的文件必须和python运行文件在同一文件包下，否则就要加上具体的地址 数据处理 补充空白数据 df.fillna(0)用0来填充空白数据 取代错误数据 df.replace(“”,0) 使用matplotlib库绘制图像 导入库 import matplotlib.pyplot as plt 选取目标数据列 df1=df[“”] 绘制柱状图 plt.hist(df1) plt.show () 绘制精确的柱状图 x=df1.value_counts().index y=df1.value_counts().value plt.bar(x,y) 绘制饼状图 plt.pie(y，labels=x，autopct=“1.1f%%”) plt.show() Data bin(不知道中文叫啥，就是把连续的变量x分成几个区间) plt.hist(df1,bins=20) plt.hist(df1,bins=[0,20,50,100]) 绘制折线图 plt.plot(df1) plt.plot(x,y) plt.xticks(rotation=30)x轴标识旋转30度 plt.xlabel(“”)x轴名字 y轴同理 plt.legend([“”,“”])折线名 plt.title() 绘制散点图 plt.scatter(x，y)","link":"/2024/01/17/Pandas/"},{"title":"线性代数-矩阵乘法后的空间原理","text":"前记 在学习线性代数的过程当中，发现很多教材对矩阵乘法的定义过于代数化了，只介绍了矩阵乘法的代数形式，而很少有提及矩阵乘法背后的空间意义，这也许会导致学习向量空间的过程当中，无法很好的联系矩阵乘法和向量张成的关系 矩阵乘法定义： 在不少的教材当中矩阵乘法都有一个代数定义，非常的简洁 ： ------------------------矩阵A=[aij]m×n矩阵B=[bij]n×s那么对于矩阵C=AB有[cij]m×s=[∑k=1naikbkj]m×s\\begin{array}{c}矩阵A={\\left[ a_{ij}\\right]_{m \\times n}} \\\\ \\\\矩阵B={\\left[ b_{ij}\\right]_{n \\times s}} \\\\ \\\\ 那么对于矩阵C=AB \\\\\\\\有\\left[ c_{ij}\\right]_{m \\times s} = \\left[ \\sum \\limits_{k=1}^{n}a_{ik}b_{kj}\\right]_{m \\times s} \\end{array}矩阵A=[aij​]m×n​矩阵B=[bij​]n×s​那么对于矩阵C=AB有[cij​]m×s​=[k=1∑n​aik​bkj​]m×s​​-------------------------- 对于已经掌握一些矩阵乘法的同学，这样的定义似乎是显而易见的，但是 对于代数基础比较薄弱的同学（比如我），这样的表述似乎是非常反人类 且令人有些畏惧的，但其实换个思路理解也许就没这么抽象了 向量与矩阵的关系 根据定义我们可以知道，向量是一个有方向和大小两个特征的量，在数学上 我们定义向量为有序的一数字，什么叫有序呢？ 举个例子 -----------------$\\left [ 1,2,3\\right ] $---------------- $ \\begin{bmatrix} a_{11} \\ a_{21} \\ \\vdots \\a_{m1}\\end{bmatrix}$-------------------------------- 像这样的有一定顺序的，从左往右，从上往下的数字，就可以表示一个向量 那么对于矩阵Am×n=[a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮am1am2⋯amn]A_{m\\times n}= \\begin{bmatrix} a_{11}&amp; a_{12}&amp; \\cdots &amp; a_{1n} \\\\ a_{21}&amp; a_{22}&amp; \\cdots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1}&amp; a_{m2}&amp; \\cdots &amp; a_{mn} \\end{bmatrix}Am×n​=⎣⎢⎢⎢⎢⎡​a11​a21​⋮am1​​a12​a22​⋮am2​​⋯⋯⋱⋯​a1n​a2n​⋮amn​​⎦⎥⎥⎥⎥⎤​，我们可以将其看作多 多个行向量的集合Am×n=[[a11a12⋯a1n][a21a22⋯a2n]⋮⋮⋱⋮[am1am2⋯amn]]A_{m\\times n}= \\begin{bmatrix} [a_{11}&amp; a_{12}&amp; \\cdots &amp; a_{1n}] \\\\ [a_{21}&amp; a_{22}&amp; \\cdots &amp; a_{2n}] \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ [a_{m1}&amp; a_{m2}&amp; \\cdots &amp; a_{mn}] \\end{bmatrix} Am×n​=⎣⎢⎢⎢⎢⎡​[a11​[a21​⋮[am1​​a12​a22​⋮am2​​⋯⋯⋱⋯​a1n​]a2n​]⋮amn​]​⎦⎥⎥⎥⎥⎤​或者是多个 列向量的集合Am×n=[[a11a21⋮am1]A_{m\\times n}= [ \\begin{bmatrix} a_{11} \\\\ a_{21} \\\\ \\vdots \\\\ a_{m1} \\end{bmatrix}Am×n​=[⎣⎢⎢⎢⎢⎡​a11​a21​⋮am1​​⎦⎥⎥⎥⎥⎤​ [a12a22⋮am2]\\begin{bmatrix} a_{12} \\\\ a_{22} \\\\ \\vdots \\\\ a_{m2} \\end{bmatrix}⎣⎢⎢⎢⎢⎡​a12​a22​⋮am2​​⎦⎥⎥⎥⎥⎤​ $\\begin{bmatrix} \\cdots \\ \\dots \\ \\vdots \\ \\cdots \\end{bmatrix} $ [a1na2n⋮amn]]\\begin{bmatrix} a_{1n} \\\\ a_{2n} \\\\ \\vdots \\\\ a_{mn} \\end{bmatrix} ]⎣⎢⎢⎢⎢⎡​a1n​a2n​⋮amn​​⎦⎥⎥⎥⎥⎤​] 也就是说，一个矩阵所展现的并不只有数字，而蕴藏了一些空间信息,从这个角度来看，不难发现矩阵运算实际上是空间当中的向量在进行运算 矩阵乘法 矩阵乘法是一个相当前置但是非常重要的东西，能够正确理解矩阵乘法对于后续的线性变换学习是相当重要的，矩阵乘法本质上就是空间的变换，这里需要补充一个比较概念叫线性组合 向量v=a1V1+a2V2+⋯+anVna_{1}V_{1}+a_{2}V_{2}+\\cdots+a_{n}V_{n}a1​V1​+a2​V2​+⋯+an​Vn​,则v是{V1，V2⋯VnV_{1}，V_{2}\\cdots V_{n}V1​，V2​⋯Vn​}的一个线性组合 而{a1,a2⋯ana_{1},a_{2}\\cdots a_{n}a1​,a2​⋯an​}是这个线性组合当中的权重 对于运算 An×nA_{n\\times n}An×n​= Bn×nB_{n\\times n}Bn×n​ x Cn×nC_{n\\times n}Cn×n​ An×n=[b11b12⋯b1nb21b22⋯b2n⋮⋮⋱⋮bn1bn2⋯bnn]A_{n\\times n}= \\begin{bmatrix} b_{11}&amp; b_{12}&amp; \\cdots &amp; b_{1n} \\\\ b_{21}&amp; b_{22}&amp; \\cdots &amp; b_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ b_{n1}&amp; b_{n2}&amp; \\cdots &amp; b_{nn} \\end{bmatrix}An×n​=⎣⎢⎢⎢⎢⎡​b11​b21​⋮bn1​​b12​b22​⋮bn2​​⋯⋯⋱⋯​b1n​b2n​⋮bnn​​⎦⎥⎥⎥⎥⎤​ [c11c12⋯c1nc21c22⋯c2n⋮⋮⋱⋮cn1cn2⋯cnn]\\begin{bmatrix} c_{11}&amp; c_{12}&amp; \\cdots &amp; c_{1n} \\\\ c_{21}&amp; c_{22}&amp; \\cdots &amp; c_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ c_{n1}&amp; c_{n2}&amp; \\cdots &amp; c_{nn} \\end{bmatrix}⎣⎢⎢⎢⎢⎡​c11​c21​⋮cn1​​c12​c22​⋮cn2​​⋯⋯⋱⋯​c1n​c2n​⋮cnn​​⎦⎥⎥⎥⎥⎤​ 其中A=[A1,A2，A3⋯AnA_{1}, A_{2}，A_{3} \\cdots A_{n}A1​,A2​，A3​⋯An​] (ANA_{N}AN​=[a1na2n⋮aNn]\\begin{bmatrix}a_{1n} \\\\a_{2n} \\\\\\vdots\\\\a_{Nn} \\end{bmatrix}⎣⎢⎢⎢⎢⎡​a1n​a2n​⋮aNn​​⎦⎥⎥⎥⎥⎤​) 那么对于ANA_{N}AN​其实是Bn×nB_{n\\times n}Bn×n​中每一列的线性组合，而权重就是Cn×n的第N列C_{n\\times n}的第N列Cn×n​的第N列，举个例子： A1=c11A_{1}=c_{1 1}A1​=c11​ [b11b21⋮bn1]+c21[b12b22⋮bn2]+⋯+cn1[b1nb2n⋮bnn]=[b11b12⋯b1nb21b22⋯b2n⋮⋮⋱⋮bn1bn2⋯bnn][c1nc2n⋮cNn]\\begin{bmatrix}b_{11}\\\\b_{21}\\\\\\vdots\\\\b_{n1}\\end{bmatrix}+c_{21}\\begin{bmatrix}b_{12}\\\\b_{22} \\\\\\vdots \\\\b_{n2} \\end{bmatrix}+\\cdots+c_{n1}\\begin{bmatrix}b_{1n}\\\\ b_{2n}\\\\\\vdots\\\\ b_{nn} \\end{bmatrix} = \\begin{bmatrix}b_{11}&amp; b_{12}&amp;\\cdots &amp; b_{1n}\\\\b_{21}&amp; b_{22}&amp; \\cdots &amp; b_{2n} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp;\\vdots\\\\ b_{n1}&amp; b_{n2}&amp; \\cdots &amp; b_{nn}\\end{bmatrix}\\begin{bmatrix} c_{1n}\\\\c_{2n}\\\\\\vdots\\\\c_{Nn}\\end{bmatrix}⎣⎢⎢⎢⎢⎡​b11​b21​⋮bn1​​⎦⎥⎥⎥⎥⎤​+c21​⎣⎢⎢⎢⎢⎡​b12​b22​⋮bn2​​⎦⎥⎥⎥⎥⎤​+⋯+cn1​⎣⎢⎢⎢⎢⎡​b1n​b2n​⋮bnn​​⎦⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎡​b11​b21​⋮bn1​​b12​b22​⋮bn2​​⋯⋯⋱⋯​b1n​b2n​⋮bnn​​⎦⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎡​c1n​c2n​⋮cNn​​⎦⎥⎥⎥⎥⎤​ 总结 在两个矩阵相乘的过程当中，新的矩阵中的每一列都是乘法左边的矩阵的每一列线性组合而成，新矩阵当中的第N列，根据右边矩阵的第N列分配权重，由左边矩阵的每一列线性组合而成，这也是为什么新矩阵的行数与左边矩阵的行数一样，列数与右边矩阵的列数一样 tips 本文仅介绍了矩阵乘法的理解思路，更具体的原理涉及到空间的线性变换，至于为什么会这么看矩阵乘法，等我哪天写一下线性变换更细致的写一下 彩蛋 事实上矩阵乘法当中每一列也有一样的原理，可以思考一下（如果你有作者的联系方式，可以联系下他讲一下你的思路，以及读完本文的想法，帮助作者更好的写文章（））","link":"/2023/11/23/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/"},{"title":"kaggle learning log_1","text":"Foreword As a student major in data science, I planned to learn machine learning at the begin of the semester1 of the 2023/2024 acadamic year. Kaggle is a platform which holds a lot of Data science competitons and it is good for me to study machine learning or something else about data science, and from now on, I will write a series of logs to record daily process. Day 1 First dayt I learnt the basic knowledge of python and panda, which contain the basic operation and grammar of python and panda. Because in the last term, I had learnt these two tools through the course Comp1012 and AMA1600,so nothing strange or new for me, the only thing which worth recording is the difference of ‘.loc’ and ‘.iloc’ Actually, if you just wanna selct a specific row these two statement are not differnet just review.loc[0] review.iloc[0] The two statements above are used to select the first row which index is 0,but if you wanna to select the specific column, you will find the difference of these two statements for example, if I wanna select the first column named “fang” review.loc[:,[‘fang’]] review.iloc[:,0] The iloc just needs the index of the column,but the loc needs the name of the column. Besides,today also review a liitle bit linear algebra, here,I recommand Professor Gillbert Strang’s book Introduction to Linear Algebra.Through this book, you can easliy know the basic theory of linear algebra. The chapter one is a introduction to vector,there are something interesting about the operation between different vector Dot products: v1 and v2 are the same dimension vector v1=(x1,y1),v2=(x2,y2)v_{1}=(x_{1},y_{1}),v_{2}=(x_{2},y_{2})v1​=(x1​,y1​),v2​=(x2​,y2​) the dot product of v1,v2 is: v1.v2=x1x2+y1y2v_{1}.v_{2}=x_{1}x_{2}+y_{1}y_{2}v1​.v2​=x1​x2​+y1​y2​ and if there is a matirx times a vector we can use the dot product to calculate it and from the defination we know that $v_{ }.w_{}=|v||w|cos\\theta $ and $ cos\\theta \\subset[-1,1]$so we can get two inequalities: Schwarz inquiality: ∣v⋅w∣≤∣v∣∣w∣|v\\cdot w|\\le |v||w|∣v⋅w∣≤∣v∣∣w∣ Triangle inequaility: ∣v+w∣≤∣v∣+∣w∣|v+w|\\le |v|+|w|∣v+w∣≤∣v∣+∣w∣ and according to Schwarz inequality we can draw that ‘geometric mean’&lt;‘arithmetic mean’ it easily to proof 12(x+y)≥xy\\frac{1}{2}(x+y)\\ge \\sqrt{xy}21​(x+y)≥xy​ but how to proof if the vector is high dimensional? let v1=(x,y,z),v2=(y,z,x),v3=(z,x,y)v_{1}=(x,y,z),v_{2}=(y,z,x),v_{3}=(z,x,y)v1​=(x,y,z),v2​=(y,z,x),v3​=(z,x,y) according to the Schwarz inequality ,we can conclude that 13(x+y+z)≥xyz3\\frac{1}{3}(x+y+z)\\ge \\sqrt[3]{xyz }31​(x+y+z)≥3xyz​ higher dimension are the same","link":"/2023/11/20/kaggle_one/"},{"title":"MultivariableCalculus_lecture1","text":"简单介绍 AMA2702多元微积分是基于AMA1702微积分的基础上的进阶课程，教科书使用DonShimamotoDon ShimamotoDonShimamoto版本的MultivariableCalculusMultivariable CalculusMultivariableCalculus，lecture1主要1介绍了向量的两种很基本的运算点积与叉积（又称内积与外积），向量的模长 模长（norm） 向量可以表示成一组有序数组，也代表着空间当中某一点的坐标，这里的模长就是空间当中数组所表示点到原点的长度，将勾股定理推广至n维可以得到 ∣v→∣=∑i=1nxi2|\\overrightarrow{v}|=\\sqrt{\\sum_{i=1}^{n}x_{i}^{2}}∣v∣=∑i=1n​xi2​​ 点积 点积是两个向量之间普遍意义上的乘法，指的是某一向量的长度与另一向量在此向量上的投影的长度的积，写作A→⋅B→\\overrightarrow{A}\\cdot\\overrightarrow{B}A⋅B, 点积可以理解为将两个列向量的其中一个转置后，形成的1xN与Nx1的两个矩阵的乘积，这意味着点积的结果是一个数 A→=(a1，a2),B→=(b1,b2)，A→⋅B→=a1b1+a2b2\\overrightarrow{A}=(a_{1}，a_{2}),\\overrightarrow{B}=(b_{1},b_{2})，\\overrightarrow{A}\\cdot\\overrightarrow{B}=a_{1}b_{1}+a_{2}b_{2}A=(a1​，a2​),B=(b1​,b2​)，A⋅B=a1​b1​+a2​b2​ 同时，根据点积的定义我们又可以得出 A→⋅B→=∣A→∣∣B→∣cos⁡θ\\overrightarrow{A}\\cdot\\overrightarrow{B}=|\\overrightarrow{A}||\\overrightarrow{B}|\\cos\\thetaA⋅B=∣A∣∣B∣cosθ 由于cos⁡θ属于（−1，1）\\cos\\theta属于（-1，1）cosθ属于（−1，1） 因而可以引出 SchwarzSchwarzSchwarz inquialityinquialityinquiality: ∣v⋅w∣≤∣v∣∣w∣|v\\cdot w|\\le |v||w|∣v⋅w∣≤∣v∣∣w∣ 这一不等式可以用于证明高维的基本不等式，详情请见kagglekagglekaggle _ oneoneone，这里不再叙述 在课上ZhangZhangZhang HuaHuaHua老师对这个不等式还提了一种特别有意思的证明 假设向量v，uv，uv，u线性相关时（即v，uv，uv，u共线） 存在常数t，使得t vvv = uuu 有∣v⋅u∣=∣tv⋅v∣=∣tv2∣=∣tv∣∣v∣=∣u∣∣v∣|v\\cdot u|=|tv\\cdot v|=|tv^{2}|=|tv||v|=|u||v|∣v⋅u∣=∣tv⋅v∣=∣tv2∣=∣tv∣∣v∣=∣u∣∣v∣ 假设向量v，uv，uv，u线性不相关时（v，uv，uv，u不共线） 此时tv≠utv\\ne utv=u，有∣tv−u∣&gt;0|tv-u|&gt;0∣tv−u∣&gt;0 平方后，t2v2−2∣tv∣∣u∣+u2&gt;0t^{2}v^{2}-2|tv||u|+u^{2}&gt;0t2v2−2∣tv∣∣u∣+u2&gt;0, 对于这个一元二次函数，我们知道它是恒大于0，f（t）=0不存在解 所以Δ=4(∣v∣∣u∣)2−4v2u2&gt;0\\Delta=4(|v||u|)^{2}-4v^{2}u^{2}&gt;0Δ=4(∣v∣∣u∣)2−4v2u2&gt;0 原式得证 真是一个富有想象力的解法，大开眼界了 Proju→v→Proj_{\\overrightarrow{u}}^{\\overrightarrow{v}}Projuv​—v在u方向的投影向量 Proju→u→=∣v→∣⋅cos⁡θ⋅u→∣u→∣Proj_{\\overrightarrow{u}}^{\\overrightarrow{u}}=|\\overrightarrow{v}|\\cdot\\cos\\theta\\cdot\\frac{\\overrightarrow{u}}{|\\overrightarrow{u}|}Projuu​=∣v∣⋅cosθ⋅∣u∣u​ cos⁡θ=u→⋅v→∣v→∣∣u→∣\\cos\\theta=\\frac{\\overrightarrow{u}\\cdot\\overrightarrow{v}}{|\\overrightarrow{v}||\\overrightarrow{u}|}cosθ=∣v∣∣u∣u⋅v​ Thus, Proju→u→=∣v→∣⋅u→⋅v→∣v→∣∣u→∣⋅u→∣u→∣Proj_{\\overrightarrow{u}}^{\\overrightarrow{u}}=|\\overrightarrow{v}|\\cdot\\frac{\\overrightarrow{u}\\cdot\\overrightarrow{v}}{|\\overrightarrow{v}||\\overrightarrow{u}|}\\cdot\\frac{\\overrightarrow{u}}{|\\overrightarrow{u}|}Projuu​=∣v∣⋅∣v∣∣u∣u⋅v​⋅∣u∣u​ 行列式 行列式的值等于矩阵任意一列或者任意一行的元素与该元素的代数余子式乘积之和，二阶矩阵行列式绝对值等于在该矩阵的作用下原坐标系中的每一个矩阵的面积变化比例，正负性代表坐标系是否被翻转，三阶则代表着立方体体积的变换比例，以此类推，详见3b1w的视频！！ 叉积 一定要明确一点的是，点积可以应用在多维向量上，但叉积只是针对三维向量的，是用于求解两个三维向量所构成平面的法向量的运算 现假设向量v,uv,uv,u是两个不共线的三维向量 向量FFF分别垂直于v，uv，uv，u 即F⋅v=0F\\cdot v=0F⋅v=0 , F⋅u=0F\\cdot u=0F⋅u=0 FFF(x,y,z) vvv(v1,v2,v3v_{1},v_{2},v_{3}v1​,v2​,v3​) uuu(u1,u2,u3u_{1},u_{2},u_{3}u1​,u2​,u3​) 我们可以得到 v1x+v2y+v3z=0v_{1}x+v_{2}y+v_{3}z=0v1​x+v2​y+v3​z=0 (1) u1x+u2y+u3z=0u_{1}x+u_{2}y+u_{3}z=0u1​x+u2​y+u3​z=0 (2) v1u2−v2u1v2x+v3u2−u3v2v2z=0\\frac{v_{1}u_{2}-v_{2}u_{1}}{v_{2}}x+\\frac{v_{3}u_{2}-u_{3}v_{2}}{v_{2}}z=0v2​v1​u2​−v2​u1​​x+v2​v3​u2​−u3​v2​​z=0 可以得到一组通解： x=v2u3−u2v3x=v_{2}u_{3}-u_{2}v_{3}x=v2​u3​−u2​v3​ y=v3u1−u3v1y=v_{3}u_{1}-u_{3}v_{1}y=v3​u1​−u3​v1​ z=v1u2−v2u1z=v_{1}u_{2}-v_{2}u_{1}z=v1​u2​−v2​u1​ 规定向量F（x，y，z）有F=v×uF=v\\times uF=v×u 此时F,v,uF,v,uF,v,u满足右手定则，食指为v方向，拇指为u方向，中指指F方向 如何判断哪个向量是v哪个向量是u呢？ （1）里的就是v，（2）里的就是u（好像是废话） 观察下式子，这个减法看上去很眼熟，交叉相乘再相减，没错，是行列式 假设这是个3×33\\times33×3的矩阵，向量v，uv，uv，u分别是矩阵的第二第三行向量 x，y，z分别是A11，A12，A13A_{11}，A_{12}，A_{13}A11​，A12​，A13​的代数余子式 这个矩阵的行列式等于A11x+A12y+A13zA_{11}x+A_{12}y+A_{13}zA11​x+A12​y+A13​z 我们知道F=ix+jy+pzix+jy+pzix+jy+pz 其中i，j，p分别是x，y，z轴上的单位向量 不妨令A11=i,A12=j,A13=pA_{11}=i,A_{12}=j,A_{13}=pA11​=i,A12​=j,A13​=p 则F=det $A=\\begin{vmatrix} i &amp; j &amp; p \\ v_{1} &amp; v_{2} &amp; v_{3} \\ u_{1} &amp; u_{2} &amp; u_{3} \\end{vmatrix} $ 从上面我们可以知道，位于矩阵第二行的向量就是食指方向向量，第三行的向量就是拇指向量 现在我们已经知道了法向量F该如何求解了，但怎么直接求解F的模长呢？ 从上述计算式我们可以得到，F的模长在数值上等于v，uv，uv，u两个向量形成的平行四边形的面积 即|F|=|v||u| sin⁡θ\\sin\\thetasinθ","link":"/2024/01/18/MultivariableCalculus_lecture1/"},{"title":"我的第一篇文章","text":"前记： 想要搭建博客已经是很久之前的想法了，学的东西太多遇到了一些很精彩的东西或者想法就想要记录下来， 但手写版的所占内容大，而且没有条理，不是非常美观， 而且有时候很想分享下自己的心情，qq空间和朋友圈熟人太多了感觉很奇怪，因而毅然决然的选择搭建一个博客，给自己的内心留下一片小天地 感谢： 非常感谢🐟哥，很大程度上是他的博客让我下定决心研究怎么搭建一个自己的博客 真的非常感谢🐟哥，在各种时候总是能给我很大的帮助，并耐心的给我很多非常有用的建议和帮助！ 想法： 在学习的过程当中，经常会有一些很神奇的想法啊，遇见很好的方法也忍不住想要分享 以后更新的文章主要是对我目前正在学习的课程的总结，和对这门课程的一些想法 偶尔会分享一些一些想法或者写写散文啥的 总的来说，希望将我的一些有用的想法记录下了，如果也能够帮助到别人就更好了！ 后记： 真的是一件大工程啊，搭建博客的过程中遇到的一些问题要不是🐟哥。。可能已经放弃了（再次感谢ty哥！！！） 我相信一定也会有想要搭建博客不知道如何搭建的朋友，待我学习一下，以后尽量出一篇文章讲一下怎么搭博客！ 以后尽量每周更新（可能） 后后记： 搭建博客我觉得最重要的就是耐心和坚持（好像不管什么东西都是这样的） 在研究怎么搭建博客的过程当中，会遇见很多莫名其妙的问题， 有时候根本没法解决只能重新来一遍，笔者调了一整天，最后才弄好主要的 部分。（真是要哭了） 总结了一些经验 1.删掉东西之前，确保你能够还原再删 2.注意中英文的符号区别，yml文件对这个非常敏感 3.不懂的东西一定要有意识的去记录产生的原因，下次遇见会方便很多 4.用vscode编辑yml文本，别拿记事本 5.注意公式应该是一个整体，公式里的东西应该在一个公式环境里而且不要有中文 6.公式/英文/数字和中文要有空格","link":"/2023/11/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"kaggle","slug":"kaggle","link":"/tags/kaggle/"},{"name":"MultivariableCalculus","slug":"MultivariableCalculus","link":"/tags/MultivariableCalculus/"},{"name":"散记","slug":"散记","link":"/tags/%E6%95%A3%E8%AE%B0/"}],"categories":[{"name":"cs","slug":"cs","link":"/categories/cs/"},{"name":"线性代数","slug":"线性代数","link":"/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"Data science","slug":"Data-science","link":"/categories/Data-science/"},{"name":"Calculus","slug":"Calculus","link":"/categories/Calculus/"},{"name":"散记","slug":"散记","link":"/categories/%E6%95%A3%E8%AE%B0/"}],"pages":[{"title":"","text":"","link":"/about/index.html"}]}